<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Event-Sourced Accounting Demo</title>
  <link rel="stylesheet" href="style.css">
  <style>
    /* small inline styles needed for the selectable modal / test area */
    :root{
      --color-success:#2ecc71;
      --color-danger:#e74c3c;
      --color-accent:#3498db;
    }
    body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial; margin:16px; background:#f6f7fb; color:#222;}
    h1{ text-align:center; margin-bottom:18px }
    .card{ background:#fff; border-radius:10px; padding:14px; margin:10px auto; max-width:1000px; box-shadow:0 6px 18px rgba(20,20,40,0.06) }
    .button-row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
    button{ background:var(--color-accent); color:#fff; border:0; padding:8px 12px; border-radius:8px; cursor:pointer }
    button.danger{ background:var(--color-danger) }
    .form-row{ display:flex; flex-wrap:wrap; gap:8px; align-items:center }
    label{ font-size:0.9rem }
    input,select{ padding:6px 8px; border-radius:6px; border:1px solid #ddd }
    table{ width:100%; border-collapse:collapse; margin-top:8px }
    th,td{ border:1px solid #eee; padding:6px; text-align:center; font-size:0.9rem }
    th{ background:#fafafa }
    .git-container .branch{ padding:8px; border-left:4px solid var(--color-accent); margin-bottom:8px; border-radius:6px; background:#fafcff }
    .branch.validated{ border-color:var(--color-success) }
    .branch.cancelled{ border-color:var(--color-danger) }
    .branch.active{ border-color:#f1c40f }
    .event-list{ list-style:none; padding-left:18px; margin:6px 0 }
    .event-dot{ margin-right:6px; color:var(--color-accent) }
    .change-info{ margin-left:8px; font-style:italic }

    /* Modal (selectable text) */
    .modal-overlay{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.35); z-index:999; }
    .modal{ background:#fff; width:560px; max-width:94%; border-radius:10px; padding:16px; box-shadow:0 8px 30px rgba(0,0,0,0.16) }
    .modal h3{ margin:0 0 8px 0 }
    .modal pre{ background:#f6f7fb; border:1px solid #eee; padding:10px; border-radius:8px; max-height:240px; overflow:auto; white-space:pre-wrap; user-select:text }
    .modal .modal-actions{ margin-top:10px; display:flex; justify-content:flex-end; gap:8px }
    .hidden{ display:none !important }

    /* Test output */
    .test-results{ background:#0b0b0b; color:#b6f2a2; font-family:monospace; padding:12px; border-radius:8px; height:180px; overflow:auto; white-space:pre-wrap }

    /* small responsive form spacing */
    .form-row > * { min-width:120px; }
  </style>
</head>
<body>

  <h1>Event-Sourced Accounting Demo</h1>

  <section class="card control-panel">
    <h2>Change Set</h2>
    <div class="button-row">
      <button id="btnStart" onclick="startChange()">Start Change</button>
      <button id="btnValidate" onclick="validateChange()">Validate</button>
      <button class="danger" id="btnCancel" onclick="cancelChange()">Cancel</button>
      <span id="currentChange" class="change-info">No active change</span>
      <span id="latestEventInfo" style="margin-left:12px; font-size:0.9rem; color:#666"></span>
    </div>
  </section>

  <section class="card input-panel">
    <h2>Add Entry</h2>
    <div class="form-row">
      <label for="type">Type:</label>
      <select id="type" onchange="populateEntries()">
        <option value="income">Income</option>
        <option value="expense">Expense</option>
      </select>

      <label for="entryCode">Entry:</label>
      <select id="entryCode"></select>

      <label for="amount">Amount:</label>
      <input id="amount" type="number" placeholder="Amount">

      <label for="startMonth">Start Month:</label>
      <input id="startMonth" type="month">

      <label for="endMonth">End Month:</label>
      <input id="endMonth" type="month">

      <button onclick="addEntry()">Add</button>
    </div>
  </section>

  <section class="card projection-panel">
    <h2>Projection (Current State)</h2>
    <div style="overflow-x:auto;">
      <table id="projectionTable">
        <thead>
          <tr id="projectionHeader">
            <th>Code</th><th>Label</th><th>Type</th><th>Status</th>
          </tr>
        </thead>
        <tbody id="projectionBody"></tbody>
        <tfoot>
          <tr class="totals" id="projectionFooter">
            <td colspan="4">Totals</td>
          </tr>
        </tfoot>
      </table>
    </div>
  </section>

  <section class="card git-view">
    <h2>Change Graph</h2>
    <div id="gitGraph" class="git-container"></div>
  </section>

  <section class="card event-log">
    <h2>Event Log</h2>
    <pre id="events" style="white-space:pre-wrap; max-height:240px; overflow:auto; font-family:monospace"></pre>
  </section>

  <!-- Test screen -->
  <section class="card test-panel">
    <h2>Business Rule Tests</h2>
    <div class="button-row" style="margin-bottom:10px">
      <button onclick="runBDDTests()">Run Tests</button>
      <button onclick="showEventsSnapshot()">Show Current Events</button>
    </div>
    <pre id="testResults" class="test-results"></pre>
  </section>

  <!-- Selectable alert modal -->
  <div id="customAlert" class="modal-overlay hidden" role="dialog" aria-modal="true">
    <div class="modal" role="document">
      <h3>Message</h3>
      <pre id="modalMessage" class="modal-text" tabindex="0"></pre>
      <div class="modal-actions">
        <button onclick="closeAlert()">OK</button>
      </div>
    </div>
  </div>

<script>
/* ============================
   Utilities & Timestamping
   ============================ */
let lastTimestamp = Date.now();
function getNextTimestamp() {
  // ensures strictly increasing timestamps (ms)
  lastTimestamp = Math.max(Date.now(), lastTimestamp + 1);
  return new Date(lastTimestamp).toISOString();
}

/* ============================
   Custom selectable alert
   ============================ */
function showAlert(message) {
  const modal = document.getElementById("customAlert");
  const msgBox = document.getElementById("modalMessage");
  msgBox.textContent = message;
  modal.classList.remove("hidden");
  msgBox.focus();
  console.log("ALERT:", message);
}
function closeAlert() {
  document.getElementById("customAlert").classList.add("hidden");
}
window.alert = showAlert; // replace native alert so all calls are selectable

/* ============================
   Tiny Pub/Sub
   ============================ */
const bus = {
  subs: {},
  on(event, fn) { (this.subs[event] ||= []).push(fn); },
  emit(event, data) { (this.subs[event] || []).forEach(fn => fn(data)); }
};

/* ============================
   In-memory store & catalog
   ============================ */
let events = [];
let projection = {};
let currentChangeId = null;

const INCOMES = [
  {code:101,label:"Salary"},{code:102,label:"Dividends"},{code:103,label:"Freelance"},
  {code:104,label:"Bonus"},{code:105,label:"Gift"},{code:106,label:"Investment Return"},
  {code:107,label:"Rent Income"},{code:108,label:"Refund"},{code:109,label:"Interest"},{code:110,label:"Other Income"},
];

const EXPENSES = [
  {code:201,label:"Rent"},{code:202,label:"Groceries"},{code:203,label:"Utilities"},
  {code:204,label:"Transportation"},{code:205,label:"Insurance"},{code:206,label:"Entertainment"},
  {code:207,label:"Healthcare"},{code:208,label:"Education"},{code:209,label:"Taxes"},{code:210,label:"Other Expense"},
];

/* ============================
   Seed data (no timestamps provided - we'll assign)
   ============================ */
const seedEventsData = [
  {type:"ChangeStarted",changeId:"C1001"},
  {type:"IncomeAdded",changeId:"C1001",entryCode:101,label:"Salary",amount:2000,startMonth:"01-2025",endMonth:"03-2025"},
  {type:"ExpenseAdded",changeId:"C1001",entryCode:202,label:"Groceries",amount:150,startMonth:"01-2025",endMonth:"02-2025"},
  {type:"ChangeValidated",changeId:"C1001"},

  {type:"ChangeStarted",changeId:"C1002"},
  {type:"IncomeAdded",changeId:"C1002",entryCode:104,label:"Bonus",amount:500,startMonth:"02-2025",endMonth:"04-2025"},
  {type:"ExpenseAdded",changeId:"C1002",entryCode:205,label:"Insurance",amount:100,startMonth:"03-2025",endMonth:"03-2025"},
  {type:"ChangeCancelled",changeId:"C1002"},

  // incomplete change (intentionally open)
  {type:"ChangeStarted",changeId:"C1003"},
  {type:"ExpenseAdded",changeId:"C1003",entryCode:206,label:"Entertainment",amount:80,startMonth:"02-2025",endMonth:"04-2025"},
];

/* When initializing, assign timestamps in chronological order */
(function initSeed(){
  let lastChange = null;
  for (const e of seedEventsData) {
    // bump time slightly whenever changeId changes (for clarity)
    if (e.changeId && e.changeId !== lastChange) {
      lastTimestamp += 60000; // jump 1 minute on new change set
      lastChange = e.changeId;
    }
    // if seed already has timestamp, keep it; otherwise generate new
    if (!e.timestamp) e.timestamp = getNextTimestamp();
    events.push({...e}); // push as-is (we will always process chronologically)
  }
})();

/* ============================
   Helpers for chronological replay
   ============================ */

function eventsChronological() {
  // returns a copy sorted by ascending timestamp (oldest first)
  return [...events].sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp));
}

function eventsReverseChronological() {
  return [...events].sort((a,b) => new Date(b.timestamp) - new Date(a.timestamp));
}

function getLatestGlobalEvent() {
  const ev = eventsReverseChronological()[0];
  return ev || null;
}

function getLastEventForChange(changeId) {
  if (!changeId) return null;
  // find last event for that change by timestamp
  const ev = eventsChronological().filter(e => e.changeId === changeId).pop();
  return ev || null;
}

function getOpenChangeId() {
  // find all changeIds and determine those not ended by validated/cancelled
  const grouped = {};
  for (const e of eventsChronological()) {
    if (!e.changeId) continue;
    grouped[e.changeId] = e; // ends up storing most recent due to chronological iteration
  }
  const open = Object.entries(grouped)
    .filter(([cid, lastEv]) => lastEv.type !== "ChangeValidated" && lastEv.type !== "ChangeCancelled")
    .map(([cid,lastEv]) => ({ changeId: cid, lastEv }));
  if (open.length === 0) return null;
  // return the one with latest timestamp
  open.sort((a,b) => new Date(b.lastEv.timestamp) - new Date(a.lastEv.timestamp));
  return open[0].changeId;
}

/* ============================
   Event API
   ============================ */

function record(event) {
  // If event has its own timestamp, use it (useful for tests); otherwise generate one
  const ev = { ...event };
  if (!ev.timestamp) ev.timestamp = getNextTimestamp();
  events.push(ev);
  rebuildProjection();
  bus.emit("eventRecorded");
  return ev;
}

/* ============================
   Business rule helpers
   ============================ */

function canStartNewChange() {
  // only allowed if there is no open change (by replay) and no active currentChangeId
  if (currentChangeId) return false;
  const open = getOpenChangeId();
  return open === null;
}

function resumeOpenChangeIfAny() {
  // When a user tries to add into the dataset that already has an open change (e.g., initial data),
  // we should resume that open change so the user can continue adding entries.
  if (currentChangeId) return currentChangeId;
  const open = getOpenChangeId();
  if (open) {
    currentChangeId = open;
  }
  return currentChangeId;
}

/* ============================
   Start / Validate / Cancel
   ============================ */

function startChange() {
  const lastEv = getLatestGlobalEvent();
  const lastType = lastEv ? lastEv.type : "None";
  const open = getOpenChangeId();

  console.log("Attempting to start a new change. currentChangeId:", currentChangeId, "openChangeId:", open, "latestGlobal:", lastType);

  if (currentChangeId) {
    showAlert(`You already have an active change: ${currentChangeId}. Validate or cancel it first.`);
    return;
  }

  if (open) {
    // there's an open change (not validated/cancelled) -> cannot start a new one
    const lastForOpen = getLastEventForChange(open);
    showAlert(
`Cannot start a NEW change.
There is an open change: ${open}
Latest event for that change is "${lastForOpen.type}" at ${lastForOpen.timestamp}

Business rule: you can only create a NEW change after the previous change has been validated or cancelled.
You may resume the open change (it will be auto-resumed when you attempt to add entries).`
    );
    return;
  }

  // allowed to start new change
  const newId = "C" + Math.floor(1000 + Math.random() * 9000);
  currentChangeId = newId;
  record({ type: "ChangeStarted", changeId: currentChangeId });
  render();
}

function validateChange() {
  if (!currentChangeId) {
    showAlert("No active change to validate.");
    return;
  }
  record({ type: "ChangeValidated", changeId: currentChangeId });
  // clear current
  currentChangeId = null;
  render();
}

function cancelChange() {
  if (!currentChangeId) {
    showAlert("No active change to cancel.");
    return;
  }
  record({ type: "ChangeCancelled", changeId: currentChangeId });
  currentChangeId = null;
  render();
}

/* ============================
   Add Entry - enforces rules
   ============================ */

function addEntry() {
  // If no currentChangeId in-memory, try to resume open change (from replay)
  if (!currentChangeId) {
    const open = getOpenChangeId();
    if (open) {
      // resume it
      currentChangeId = open;
      const lastForOpen = getLastEventForChange(open);
      showAlert(
`Resuming open change: ${open}
Latest event for this change is "${lastForOpen.type}" at ${lastForOpen.timestamp}

You can now add/modify entries for this change.`
      );
      // proceed (currentChangeId set)
    } else {
      const latest = getLatestGlobalEvent();
      const latestType = latest ? latest.type : "None";
      showAlert(`Cannot add entry — no active change.\nLatest event is "${latestType}".\nStart a new change (only allowed after previous change is validated or cancelled).`);
      console.warn("Add entry blocked. No active change and no open change. Latest:", latestType);
      return;
    }
  }

  // Ensure this change is still open (not validated/cancelled)
  const lastForCurrent = getLastEventForChange(currentChangeId);
  const lastTypeForCurrent = lastForCurrent ? lastForCurrent.type : "None";
  if (lastTypeForCurrent === "ChangeValidated" || lastTypeForCurrent === "ChangeCancelled") {
    showAlert(`Cannot add entry — change ${currentChangeId} is already ${lastTypeForCurrent}.`);
    currentChangeId = null;
    return;
  }

  // At this point, currentChangeId is set and that change is open/pending -> proceed
  const type = document.getElementById("type").value;
  const code = document.getElementById("entryCode").value;
  const label = getLabelByCode(type, code);
  const amount = Number(document.getElementById("amount").value);
  const startMonthInput = document.getElementById("startMonth").value;
  const endMonthInput = document.getElementById("endMonth").value;

  if (!amount) { showAlert("Enter an amount!"); return; }
  if (!startMonthInput || !endMonthInput) { showAlert("Enter start and end months!"); return; }

  const startMonth = convertMonthFormat(startMonthInput);
  const endMonth = convertMonthFormat(endMonthInput);

  const evType = type === "income" ? "IncomeAdded" : "ExpenseAdded";
  record({ type: evType, changeId: currentChangeId, entryCode: code, label, amount, startMonth, endMonth });
  // keep currentChangeId open so user can add more entries until they Validate or Cancel
  document.getElementById("amount").value = "";
  document.getElementById("startMonth").value = "";
  document.getElementById("endMonth").value = "";
  render();
}

/* ============================
   Month helpers (input type=month -> record "MM-YYYY")
   ============================ */
function convertMonthFormat(yyyyMm) {
  if (!yyyyMm) return '';
  const [year, month] = yyyyMm.split('-');
  return `${month}-${year}`;
}
function isValidMonth(monthStr) {
  const match = monthStr.match(/^(\d{2})-(\d{4})$/);
  if (!match) return false;
  const month = parseInt(match[1], 10);
  return month >= 1 && month <= 12;
}
function parseMonth(monthStr) {
  const [m, y] = monthStr.split("-");
  return { month: parseInt(m,10), year: parseInt(y,10) };
}
function getMonthsBetween(start, end) {
  const months = [];
  const s = parseMonth(start);
  const e = parseMonth(end);
  let curr = { ...s };
  while (curr.year < e.year || (curr.year === e.year && curr.month <= e.month)) {
    months.push(`${String(curr.month).padStart(2,'0')}-${curr.year}`);
    curr.month++;
    if (curr.month > 12) { curr.month = 1; curr.year++; }
  }
  return months;
}

/* ============================
   Projection logic (replay chronologically)
   ============================ */
function rebuildProjection() {
  projection = {};
  const byChrono = eventsChronological();
  for (const e of byChrono) applyEvent(e);
  bus.emit("projectionUpdated");
}

function applyEvent(e) {
  if (!e || !e.type) return;
  const entryKey = e.changeId && e.entryCode ? `${e.changeId}-${e.entryCode}` : null;
  switch (e.type) {
    case "IncomeAdded":
    case "ExpenseAdded":
      if (entryKey) projection[entryKey] = { ...e, status: "pending" };
      break;
    case "ChangeValidated":
      // mark all entries in this change validated
      for (const k of Object.keys(projection)) {
        if (k.startsWith(e.changeId + '-')) projection[k].status = "validated";
      }
      break;
    case "ChangeCancelled":
      // remove entries for this change
      for (const k of Object.keys(projection)) {
        if (k.startsWith(e.changeId + '-')) delete projection[k];
      }
      break;
    case "ChangeStarted":
      // nothing to projection directly; used to identify open changes
      break;
  }
}

/* ============================
   Rendering
   ============================ */
function renderProjection() {
  const allMonths = getAllMonths();
  const header = document.getElementById("projectionHeader");
  const tbody = document.getElementById("projectionBody");
  const footer = document.getElementById("projectionFooter");

  header.innerHTML = "<th>Code</th><th>Label</th><th>Type</th><th>Status</th>";
  allMonths.forEach(month => header.innerHTML += `<th>${month}</th>`);

  tbody.innerHTML = "";
  const monthTotals = {};
  allMonths.forEach(m => monthTotals[m] = 0);

  const sortedKeys = Object.keys(projection).sort();

  for (const key of sortedKeys) {
    const e = projection[key];
    const typeLabel = e.type === "IncomeAdded" ? "Income" : "Expense";
    const multiplier = typeLabel === "Income" ? 1 : -1;
    let row = `<tr class="${typeLabel.toLowerCase()} ${e.status}">
      <td>${e.entryCode}</td>
      <td>${e.label}</td>
      <td>${typeLabel}</td>
      <td>${e.status}</td>`;
    allMonths.forEach(month => {
      const entryMonths = (isValidMonth(e.startMonth) && isValidMonth(e.endMonth)) ? getMonthsBetween(e.startMonth, e.endMonth) : [];
      if (entryMonths.includes(month)) {
        row += `<td>${Number(e.amount).toFixed(2)}</td>`;
        monthTotals[month] += Number(e.amount) * multiplier;
      } else {
        row += `<td>-</td>`;
      }
    });
    row += "</tr>";
    tbody.insertAdjacentHTML("beforeend", row);
  }

  footer.innerHTML = "<td colspan='4'>Totals</td>";
  allMonths.forEach(month => {
    const total = monthTotals[month] || 0;
    const style = total < 0 ? `color:${getComputedStyle(document.documentElement).getPropertyValue('--color-danger')}` : `color:${getComputedStyle(document.documentElement).getPropertyValue('--color-success')}`;
    footer.innerHTML += `<td style="${style}">${total.toFixed(2)}</td>`;
  });
}

function getAllMonths() {
  const monthSet = new Set();
  for (const k in projection) {
    const entry = projection[k];
    if (entry.startMonth && entry.endMonth && isValidMonth(entry.startMonth) && isValidMonth(entry.endMonth)) {
      getMonthsBetween(entry.startMonth, entry.endMonth).forEach(m => monthSet.add(m));
    }
  }
  return Array.from(monthSet).sort((a,b) => {
    const [am, ay] = a.split('-'); const [bm, by] = b.split('-');
    if (ay !== by) return ay - by;
    return am - bm;
  });
}

function renderGitGraph() {
  const graphDiv = document.getElementById("gitGraph");
  graphDiv.innerHTML = "";
  // collect changeIds with chronological events
  const byChrono = eventsChronological();
  const changeIds = [...new Set(byChrono.map(e => e.changeId).filter(Boolean))].reverse();
  changeIds.forEach(cid => {
    const branchEvents = byChrono.filter(e => e.changeId === cid);
    const last = branchEvents[branchEvents.length - 1];
    let statusClass = "";
    let statusIcon = "●";
    if (last?.type === "ChangeValidated") { statusClass = "validated"; statusIcon = "✓"; }
    else if (last?.type === "ChangeCancelled") { statusClass = "cancelled"; statusIcon = "✕"; }
    else statusClass = "active";
    const branch = document.createElement("div");
    branch.className = `branch ${statusClass}`;
    branch.innerHTML = `
      <div class="branch-header"><span class="branch-icon">${statusIcon}</span> <strong style="margin-left:6px">${cid}</strong> <span style="color:#666; margin-left:8px; font-size:0.9rem">(${last.type})</span></div>
      <ul class="event-list">
        ${branchEvents.map(e => {
          let detail = "";
          if (e.label && e.amount) detail += ` <span class="event-detail">(${e.label}: $${e.amount})</span>`;
          if (e.startMonth) detail += ` [${e.startMonth}${e.endMonth && e.endMonth !== e.startMonth ? ` to ${e.endMonth}` : ''}]`;
          return `<li><span class="event-dot">•</span> ${e.type} <small style="color:#666">@${e.timestamp}</small>${detail}</li>`;
        }).join("")}
      </ul>
    `;
    graphDiv.appendChild(branch);
  });
}

function renderEventsLog() {
  // show reverse chronological for readability (newest first)
  const sorted = eventsReverseChronological();
  document.getElementById("events").textContent = JSON.stringify(sorted, null, 2);
}

function renderCurrentInfo() {
  document.getElementById("currentChange").textContent = currentChangeId ? `Active Change: ${currentChangeId}` : "No active change";
  const latest = getLatestGlobalEvent();
  document.getElementById("latestEventInfo").textContent = latest ? `Latest: ${latest.type} (${latest.changeId || "no-changeId"}) @ ${latest.timestamp}` : '';
}

function render() {
  renderEventsLog();
  renderCurrentInfo();
  renderProjection();
  renderGitGraph();
}

/* ============================
   Helpers for UI population
   ============================ */
function getLabelByCode(type, code) {
  const list = type === "income" ? INCOMES : EXPENSES;
  return list.find(x => String(x.code) === String(code))?.label || "";
}
function populateEntries() {
  const select = document.getElementById("entryCode");
  const type = document.getElementById("type").value;
  const list = type === "income" ? INCOMES : EXPENSES;
  select.innerHTML = list.map(e => `<option value="${e.code}">${e.code} - ${e.label}</option>`).join("");
}

/* ============================
   BDD Test Runner
   ============================ */
    /* === Simple BDD Tests === */
    function runBDDTests(){
      const out=document.getElementById("testResults");
      const results=[];
      const test=(name,fn)=>{try{fn();results.push(`✅ ${name}`);}catch(e){results.push(`❌ ${name}: ${e.message}`);}};

      test("Given validated change → cannot start new without cancel/validate",()=>{
        const evs=[{type:"ChangeStarted",changeId:"C1"},{type:"IncomeAdded",changeId:"C1"},{type:"ChangeValidated",changeId:"C1"}];
        const active=(()=>{let a=null;for(const e of evs){if(e.type==="ChangeStarted")a=e.changeId;if(["ChangeValidated","ChangeCancelled"].includes(e.type)&&a===e.changeId)a=null;}return a;})();
        if(active!==null) throw new Error("Expected no active change");
      });

      test("ChangeStarted allows adding income",()=>{
        const evs=[{type:"ChangeStarted",changeId:"C2"}];
        const active=(()=>{let a=null;for(const e of evs){if(e.type==="ChangeStarted")a=e.changeId;}return a;})();
        if(!active) throw new Error("Expected active change");
      });

      test("Cancelled change resets state",()=>{
        const evs=[{type:"ChangeStarted",changeId:"C3"},{type:"ChangeCancelled",changeId:"C3"}];
        const active=(()=>{let a=null;for(const e of evs){if(e.type==="ChangeStarted")a=e.changeId;if(e.type==="ChangeCancelled"&&a===e.changeId)a=null;}return a;})();
        if(active!==null) throw new Error("Expected cancelled change to clear active state");
      });

      // ✅ New test for your current state — validating C1003 works
      test("Given C1003 is started → validate should succeed",()=>{
        const evs=[
          {type:"ChangeStarted",changeId:"C1003"},
          {type:"ExpenseAdded",changeId:"C1003",entryCode:206,label:"Entertainment",amount:80,startMonth:"02-2025",endMonth:"04-2025"}
        ];
        let active=null;
        for(const e of evs){
          if(e.type==="ChangeStarted") active=e.changeId;
          if(["ChangeValidated","ChangeCancelled"].includes(e.type) && active===e.changeId) active=null;
        }
        if(!active) throw new Error("Expected C1003 to be active before validation");

        // Simulate validation
        evs.push({type:"ChangeValidated",changeId:"C1003"});
        for(const e of evs){
          if(e.type==="ChangeStarted") active=e.changeId;
          if(["ChangeValidated","ChangeCancelled"].includes(e.type) && active===e.changeId) active=null;
        }
        if(active!==null) throw new Error("Expected C1003 to be inactive after validation");
      });

      out.innerHTML=results.map(r=>r.includes("✅")?`<div class='test-pass'>${r}</div>`:`<div class='test-fail'>${r}</div>`).join("");
    }
/* quick helper to show current events in test output */
function showEventsSnapshot() {
  document.getElementById("testResults").textContent = JSON.stringify(eventsChronological(), null, 2);
}

/* ============================
   Subscriptions & Init
   ============================ */
bus.on("eventRecorded", render);
bus.on("projectionUpdated", renderProjection);

// initial UI setup
populateEntries();
rebuildProjection();
render();

</script>

</body>
</html>
